# 에디터 사용법

1. 에디터 뷰에서 목록에서 선택한 액터를 화면 중앙에 위치하려면 더블 클릭을 했는데, 클릭 한 다음에 F(ocus)를 눌러도 됨.

2. 액터 움직일 때는 에디터 뷰 우측 상단에 있는 Snap 격자 설정을 조정해도 됨.

3. 언리얼5에서는 에디터에서도 시각순응(자동노출) 기능이 활성화되어 있고, 옵션으로 조정 가능함.

4. 에디터 뷰 선택 모드에서 이동이나 크기 조정의 경우 x,y,z 기즈모 중점 가까에 있는 작은 사각형을 이용해 축 2개에 대한 조작을 한번에 할 수 있음.



# 언리얼 엔진에서 BlueprintPure

언리얼 엔진에서 **`UFUNCTION`** 키워드 중 **`BlueprintPure`**는 해당 함수가 블루프린트에서 사용 가능하며, **상태를 변경하지 않는 함수**임을 나타냅니다. 즉, 사이드 이펙트가 없는 순수 함수로, 단순히 값을 반환하는 역할을 합니다.

## `BlueprintPure`의 주요 특징

1. **상태 변경 없음**:
   - `BlueprintPure`로 선언된 함수는 호출될 때 **게임 상태나 객체의 멤버 변수를 변경하지 않습니다**. 함수는 단순히 입력을 받아 결과를 반환하거나, 객체의 상태를 읽고 그 값을 반환하는 역할을 수행합니다.

2. **실행 핀이 없음**:
   - 블루프린트 에디터에서 **`BlueprintPure`** 함수는 **실행 흐름 핀(Execution Pin)**이 없습니다. 일반 블루프린트 함수는 실행 흐름을 제어하는 핀을 가지지만, `BlueprintPure` 함수는 단순히 값을 반환하므로 실행 흐름을 제어하지 않습니다.
   
3. **반환값 필수**:
   - `BlueprintPure` 함수는 항상 **반환값**을 가져야 합니다. 반환값이 없는 함수는 `BlueprintPure`로 선언할 수 없습니다. 이러한 함수는 단순히 값을 계산하여 반환하는 역할을 합니다.

4. **예시**:
   아래는 `BlueprintPure` 키워드를 사용한 함수의 예시입니다.

   ```cpp
   UFUNCTION(BlueprintPure, Category="Math")
   float GetCircleArea(float Radius) const
   {
       return PI * Radius * Radius;
   }
   ```

   이 함수는 반지름 값을 입력받아 원의 면적을 계산하여 반환합니다. 이 함수는 단순히 값을 반환하는 역할만 하며, 상태를 변경하지 않기 때문에 순수 함수입니다.

## 언제 사용하나요?

- **순수한 계산 함수**나 **상태 조회 함수**에 주로 사용됩니다. 예를 들어, 특정 값의 제곱을 구하거나 벡터 연산을 수행하는 함수, 또는 객체의 상태를 읽고 반환하는 함수에서 사용됩니다.
- 함수의 결과가 **호출할 때마다 동일**하며, **다른 시스템의 상태에 영향을 미치지 않는** 경우 사용합니다.

## 예시: `BlueprintCallable` vs `BlueprintPure`

다음 예시는 두 키워드의 차이를 설명합니다:

- **`BlueprintCallable`**:

  ```cpp
  UFUNCTION(BlueprintCallable, Category="Game")
  void IncreaseScore(int Amount);
  ```

  이 함수는 **점수를 증가**시키며, 호출 시 게임 상태에 영향을 미칩니다. 따라서 실행 흐름을 제어하는 **실행 핀**이 필요합니다.

- **`BlueprintPure`**:

  ```cpp
  UFUNCTION(BlueprintPure, Category="Game")
  int GetScore() const;
  ```

  이 함수는 **현재 점수를 단순히 반환**하는 함수로, 상태를 변경하지 않습니다. 실행 핀이 없으며, 순수 함수로 동작합니다.

## 요약
- **`BlueprintPure`**: 블루프린트에서 **상태를 변경하지 않고 값을 반환하는 함수**를 정의하는 데 사용됩니다.
- **실행 핀 없이** 속성 노드처럼 동작하며, 항상 반환값이 있어야 합니다.
- 주로 **읽기 전용 함수**나 **계산 함수**에 사용됩니다.


# 언리얼 엔진 리플렉션 프로그래밍

언리얼 엔진에서 **리플렉션(Reflection)**은 **코드 메타데이터**를 기반으로 객체와 속성, 함수 등을 런타임에 **동적으로 접근**하고 **조작**할 수 있는 기능을 의미합니다. 이 개념은 언리얼의 **UCLASS**, **USTRUCT**, **UENUM**, **UFUNCTION**, **UPROPERTY** 같은 매크로들을 통해 제공되며, 주로 **언리얼 오브젝트 시스템**과 **블루프린트 통합**에 활용됩니다.

언리얼에서의 리플렉션은 개발자가 게임 객체의 클래스와 속성을 런타임에 쉽게 접근하고, 이를 활용해 블루프린트와의 상호작용, 직렬화, 편집기에서의 노출, 네트워크 복제 등을 가능하게 합니다.

### 리플렉션의 주요 기능

1. **런타임 객체 정보 접근**:
   - 리플렉션 시스템을 통해 객체의 클래스 정보, 속성 및 메서드에 런타임에서 동적으로 접근할 수 있습니다. 이를 통해 **클래스 이름**, **함수 이름**, **속성 타입** 등을 확인하고, 해당 객체의 데이터를 조작할 수 있습니다.
   
2. **블루프린트 통합**:
   - 언리얼의 리플렉션 시스템은 **블루프린트**와 **C++ 코드**를 연결해 줍니다. C++로 작성된 클래스와 함수를 블루프린트에서 사용할 수 있게 하기 위해 `UFUNCTION`과 `UPROPERTY` 같은 매크로를 사용하여 리플렉션을 적용합니다.
   - 이를 통해 C++ 코드에서 정의한 함수나 속성을 블루프린트에서 쉽게 호출하고 조작할 수 있게 됩니다.

3. **에디터 노출**:
   - 리플렉션을 통해 언리얼 엔진 에디터에서 클래스 속성을 노출할 수 있습니다. `UPROPERTY` 매크로를 사용하면, 에디터에서 해당 속성을 직관적으로 수정하거나 접근할 수 있게 만들 수 있습니다.
   - 예시:
     ```cpp
     UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Settings")
     float Health;
     ```
     이 코드는 `Health` 변수를 에디터에서 수정할 수 있게 하며, 블루프린트에서도 읽기/쓰기 가능하게 설정합니다.

4. **직렬화(Serialization)**:
   - 리플렉션 시스템을 통해 객체 데이터를 저장하거나 불러오는 과정인 **직렬화**를 자동으로 처리할 수 있습니다. 이를 통해 언리얼 엔진의 저장/불러오기 시스템을 간편하게 구축할 수 있습니다.

5. **네트워크 복제**:
   - 멀티플레이어 게임에서 객체의 속성을 네트워크를 통해 자동으로 복제하는 기능을 지원합니다. 리플렉션 시스템을 사용하여 `UPROPERTY` 매크로에 `Replicated` 옵션을 지정하면, 해당 속성이 서버와 클라이언트 간에 자동으로 동기화됩니다.
   - 예시:
     ```cpp
     UPROPERTY(Replicated)
     int32 AmmoCount;
     ```

6. **가비지 컬렉션**:
   - 리플렉션 시스템은 언리얼 엔진의 **가비지 컬렉션 시스템**과 밀접하게 연동됩니다. `UCLASS`로 선언된 객체들은 엔진의 가비지 컬렉션 시스템이 관리하며, 불필요한 메모리 사용을 방지할 수 있습니다.

### 리플렉션을 사용하는 매크로들

1. **UCLASS**:
   - 클래스에 리플렉션을 적용하여 언리얼 엔진의 객체로 인식되게 만드는 매크로입니다. 이를 통해 에디터나 블루프린트에서 해당 클래스를 사용할 수 있습니다.
     ```cpp
     UCLASS()
     class AMyCharacter : public ACharacter
     {
         GENERATED_BODY()
     };
     ```

2. **UFUNCTION**:
   - 클래스 내 함수를 블루프린트나 엔진 시스템에서 사용할 수 있도록 지정하는 매크로입니다. 함수가 블루프린트에서 호출되거나, 리플렉션 시스템을 통해 런타임에 동적으로 호출되도록 할 수 있습니다.
     ```cpp
     UFUNCTION(BlueprintCallable, Category="Game")
     void Jump();
     ```

3. **UPROPERTY**:
   - 클래스 속성을 리플렉션 시스템에서 관리하고, 블루프린트 또는 에디터에서 해당 속성을 사용할 수 있도록 만드는 매크로입니다.
     ```cpp
     UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Stats")
     float Health;
     ```

4. **USTRUCT**:
   - 리플렉션이 적용된 사용자 정의 구조체를 선언할 때 사용됩니다. 이를 통해 구조체도 블루프린트와 연동할 수 있으며, 객체 직렬화 및 네트워크 복제에도 사용할 수 있습니다.
     ```cpp
     USTRUCT(BlueprintType)
     struct FPlayerStats
     {
         GENERATED_BODY()

         UPROPERTY(EditAnywhere, BlueprintReadWrite)
         int32 Score;
     };
     ```

5. **UENUM**:
   - 열거형(enum)에 리플렉션을 적용하여 블루프린트에서 해당 열거형을 사용할 수 있게 해주는 매크로입니다.
     ```cpp
     UENUM(BlueprintType)
     enum class EWeaponType : uint8
     {
         Pistol UMETA(DisplayName="Pistol"),
         Rifle UMETA(DisplayName="Rifle")
     };
     ```

### 리플렉션의 주요 활용 예시

1. **블루프린트에서 C++ 함수 호출**:
   C++로 작성한 함수를 블루프린트에서 호출하여 게임플레이를 제어하거나 게임 로직을 확장할 수 있습니다. 예를 들어, 점프 기능을 C++로 작성하고 블루프린트에서 호출하는 방식입니다.

2. **런타임 동적 객체 생성**:
   리플렉션 시스템을 통해 **런타임에 특정 클래스의 객체를 생성**할 수 있습니다. 예를 들어, 문자열로 클래스 이름을 받아서 런타임에 해당 클래스를 생성하는 기능을 구현할 수 있습니다.

3. **에디터에서 변수 조정**:
   리플렉션을 사용하면 에디터에서 변수들을 쉽게 노출하고, 에디터 사용자들이 직접 값을 조정하여 게임플레이에 영향을 줄 수 있도록 할 수 있습니다.

### 요약
언리얼 엔진에서 **리플렉션**은 객체와 그 속성, 메서드 등을 런타임에 동적으로 접근하고, 블루프린트와의 상호작용을 쉽게 하도록 해주는 시스템입니다. 이를 통해 **블루프린트 통합**, **에디터 노출**, **직렬화**, **네트워크 복제**와 같은 다양한 기능을 구현할 수 있습니다.


# 언리얼 그래픽스

### 레벨인스턴스
UE4에서는 스트리밍 레벨을 사용했지만
UE5 에서는 레벨인스턴스를 통해
레벨 내에서 재배치 가능한 작은 서브레벨로 활용한다.

### 나나이트
언리얼 엔진5에서 도입된 가상화 지오메트리 시스템으로 카메라의 거리에 
따라 메시 변경을 최적화하는 LOD 기능의 업그레이드 버전이라고
쉽게 이해할 수 있다.
엔진 스스로 메시를 계산해둔 클러스터를 바탕으로 메시를 재조합하는 원리이기 때문에 추가 메시가 필요없는 장점이 있다.

### 루멘
루멘은 실시간 레이트레이싱을 소프트웨어 적으로 비교적 간소화게 표현한 것이라고 볼 수 있으며, 루멘은 사물이나 지표면 같은 액터들의 반사광을 실시간으로 처리하게 되지만, 하늘 대기에 반사된 빛은 표현하지 않기 때문에 Sky Light 같은 조명 액터를 통해 보충하게 된다.

### 대기 표현
하늘은 Sky Atmosphere 액터를 설치해 대기를 표현한다.
실제 대기에 영향을 주는 요소들 - 대기의 높이, 대기 중의 먼지, 수증기, 오존의 농도 - 를 조정해 시뮬레이션에 가까울 정도로 사실적인 대기표현이 가능하며 행성을 표현하는 능력이 뛰어나 우주급 규모의 비주얼을 구현한다.
다양한 대기 산란( 레일리 산란, 미에 산란, 홉수 ) 설정을 지원한다.

### 포그 이펙트
Exponential Height Fog 는 맵의 높이에 따라 반비례하는 안개의 농도를 부드럽게 전환시켜 그 고도차에 따른 경계선이 눈에 띄지 않게 배치한다.

창문으로 들어오는 햇살의 빛 번짐이나 안개가 짙은 날 가로등의 빛이 안개에 퍼져 뿌옇게 빛무리가 생기는 현상을 본 적이 있을 것이다. 이것은 안개에 빛이 산란해 생기는 빛 무리 현상으로 언리얼에서는 Volumetric Fog 라는 이름으로 구현한다.

### LightMass
라이트 액터는 사물을 비추는 단계인 직접광만을 표현하고 빛이 물체를 튕겨 나오는 간접광은 계산하지 않습니다. 그래서 모자란 빛의 표현은 추가적인 라이트 액터로 보충하기도 하는데, 계산을 해야하는 라이트 개수가 많으면 퍼포먼스에 영향을 줄 수 밖에 없습니다. 그렇다고 라이트 설계를 잘해서 최소한으로 배치를 한다고 해도 공간이 넓어지면 라이트 개수를 줄이는 방법에는 한계가 있습니다. 그래서 실시간 엔진에서는 이를 해결하기 위해 라이트를 실시간으로 계산해 그 결과물을 이미지 텍스쳐에 담아두고 컨텐츠가 작동할 때 이미 계산된 텍스쳐를 불러오는 방법을 쓰기도 합니다
이런 방법을 언리얼에서는 라이트매스라고 하며, 라이트를 미리 계산해 이미지 텍스쳐에 담아두는 작업을 라이트매핑, 담아둔 텍스쳐를 라이트맵이라고 부릅니다.
Lightmass Importance Volume 을 설치해 라이트매스가 작동할 때 중요한 부분을 집중적으로 계산할 수 있도록 설정합니다.

### Reflection
리플렉션 액터는 물, 금속, 거울과 같이 매끈한 ( PBR 머터리얼의 Roughness 0 에 가까운 물체) 표면 주변의 상이 비쳐 보이는 현상을 만들어 주는 액터로 박스형, 구체형, 평면형으로 구분해 제공하고 있습니다.

### 포스트 프로세스 이펙트
기존의 효과들과 달리 카메라에만 적용되는 효과입니다.
뽀샤시 효과인 블룸
구석의 실감나는 음영인 앰비엔터 오클루전
화면 주위를 어둡게 해서 가운데로 집중할 수 있도록 하는 비네트(Vignette) 효과
포토샵의 샤픈(Sharpen) 효과
사진 촬영에 잘 쓰이는 DOF(Depth Of Field) 효과
화면색 보정인 컬러 그레이딩 등이 이 기능에 속합니다.

프로젝트 세팅 창에서 프로젝트 단위로 설정 on/off 가 가능하며
PostProcess  Volume 을 통해 자체 구현도 가능합니다.

### Wet Ground 머터리얼 예시
필요에 따라 다양한 표현식을 활용하여 하나의 머터리얼로 다양한 변화를 묘사할 수 있다. 건조한 땅과 젖어있는 땅을 표현하는 것도 그 중 하나이다.

현실에서 물에 젖은 부위는 색이 진해지거나, 선명함이 더 잘 보이는 경우를 Multiply Node 를 통해 표현할 수 있다.
Smooth Step Node를 통해 물에 젖은 정도를 Roughness 를 조절해 표현할 수 있다.
Normal 맵을 약간 보정해서 물로 인해 굴곡진 효과도 표현할 수 있다.

### Energy Field 효과 머터리얼 예시
반투명 효과
프레넬 효과(Fresnel, 경계, 윤곽선을 포현하기 위해 바라보는 각도에 따라 반사가 일어나거나 투과되는 정도가 바뀌는 현상) 
Depth Fade - 다른 오브젝트와 맞닿을 때 경계를 표현하는 데 사용 - 나 UV 좌표 변화를 통해 텍스쳐 애니메이션을 조합하여 표현 가능하다

### Post Process Effect 머터리얼 예시
포스트 프로세스 머터리얼은 포스트 프로세스 이펙트에 있는 기능과 더불어 머터리얼 셋업을 통해 대미지, 광역 효과용 비주얼 스크린 이펙트를 만들거나 포스트 프로세스 이펙트를 통해서만 가능한 게임 전반적인 분위기를 낼 수 있습니다.
화면 모자이크 효과는 UV 좌표에서 Linear 좌표를 계단처럼 수정하는 과정을 통해 표현할 수 있습니다. 직선형의 그래프를 계단처럼 사용하기 위해 Floor(버림), Ceil(올림), Round(반올림) 과 같은 노드를 사용해 표현할 수 있습니다.
포스트 프로세스 머터리얼은 성능 비용이 큽니다.
가급적이면 색 보정이나 조정, 블룸, DOF 등 여러 이펙트에 대해 최적화도 잘 되어 있고, 효율적인 포스트프로세스볼륨의 상속된 세팅을 사용하는 것이 좋고 만약 사용해야 한다면 꼭 필요할 때만 사용하는 것이 좋습니다.

### 나이아가라
언리얼4에서는 Cascade 를 이용해 VFX 를 표현했으나, UE5에서는 나이아가라를 사용하는 것이 좋습니다.
Emitter, Particle 등으로 불꽃 효과를 포함해 여러 다양한 특수효과를 구현합니다. Particle spawn 이나 그와 관련된 속성을 컨트롤 합니다.
특수효과를 작업할 때 크기를 가늠하기 위해 옆에 사람이나 기본 유닛 박스를 세워두고 작업하는 것은 작업상의 팁.
단순한 입자 파티클도 사용할 수 있고
Sequence Texture 를 이용해 스프라이트 애니메이션이 되는 입자를 사용할 수도 있다.
파티클 시스템은 어렸을 때 직접 만들어봐서 별로 새로운 시스템 공부하거나 접할 때 부담이 없네.

### 시퀀스 애니메이션
언리얼3의 마티네.
CFHD 처음 왔을 때, 호기심에 직접 만져보기도 했는데..
지금은 연출팀에서 거의 사용하니, 내가 만질 일은 앞으로도 없을 듯.
그냥 키프레임 애니메이션 처럼 주로 카메라 연출을 다루고
배우를 다루듯이 스케레탈메시를 포함한 액터들의 연출도 컨트롤 함.

### 애니메이션 리타게팅
스켈레탈 메시끼리 애니메이션을 공유할 수 있도록 서로 연결해주는 과정을 Retargeting 이라고 함.
대충 원리는 원본 스케레탈 메시에서 지정된 Root bone 으로부터 하위로 관절 정보를 탐색하면서 Chain 이라는 이름으로 본(Rig) 계층 정보를 생성함.
그리고 이 생성된 정보를 대상 스켈레탈 메시의 Root bone 으로부터 역으로 매핑하면서 적용함. 그리고 애니메이션 정보를 공유함.
이게 인간형 스켈레탈 메시에는 자동으로 적용이 되고, 크게 어색하지 않게 적용되나 비인간형 스켈레탈 메시에는 적용 자체가 어려운 경우도 많고 ( 당연히 계층 구조가 다를테니 ) 좀 비슷한 계층 구조를 가지고 있다해도 수동으로 Retargeting 정보를 조정해줘야 하는 경우가 많음.
