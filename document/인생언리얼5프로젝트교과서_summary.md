# 에디터 사용법

1. 에디터 뷰에서 목록에서 선택한 액터를 화면 중앙에 위치하려면 더블 클릭을 했는데, 클릭 한 다음에 F(ocus)를 눌러도 됨.

2. 액터 움직일 때는 에디터 뷰 우측 상단에 있는 Snap 격자 설정을 조정해도 됨.

3. 언리얼5에서는 에디터에서도 시각순응(자동노출) 기능이 활성화되어 있고, 옵션으로 조정 가능함.

4. 에디터 뷰 선택 모드에서 이동이나 크기 조정의 경우 x,y,z 기즈모 중점 가까에 있는 작은 사각형을 이용해 축 2개에 대한 조작을 한번에 할 수 있음.



# 언리얼 엔진에서 BlueprintPure

언리얼 엔진에서 **`UFUNCTION`** 키워드 중 **`BlueprintPure`**는 해당 함수가 블루프린트에서 사용 가능하며, **상태를 변경하지 않는 함수**임을 나타냅니다. 즉, 사이드 이펙트가 없는 순수 함수로, 단순히 값을 반환하는 역할을 합니다.

## `BlueprintPure`의 주요 특징

1. **상태 변경 없음**:
   - `BlueprintPure`로 선언된 함수는 호출될 때 **게임 상태나 객체의 멤버 변수를 변경하지 않습니다**. 함수는 단순히 입력을 받아 결과를 반환하거나, 객체의 상태를 읽고 그 값을 반환하는 역할을 수행합니다.

2. **실행 핀이 없음**:
   - 블루프린트 에디터에서 **`BlueprintPure`** 함수는 **실행 흐름 핀(Execution Pin)**이 없습니다. 일반 블루프린트 함수는 실행 흐름을 제어하는 핀을 가지지만, `BlueprintPure` 함수는 단순히 값을 반환하므로 실행 흐름을 제어하지 않습니다.
   
3. **반환값 필수**:
   - `BlueprintPure` 함수는 항상 **반환값**을 가져야 합니다. 반환값이 없는 함수는 `BlueprintPure`로 선언할 수 없습니다. 이러한 함수는 단순히 값을 계산하여 반환하는 역할을 합니다.

4. **예시**:
   아래는 `BlueprintPure` 키워드를 사용한 함수의 예시입니다.

   ```cpp
   UFUNCTION(BlueprintPure, Category="Math")
   float GetCircleArea(float Radius) const
   {
       return PI * Radius * Radius;
   }
   ```

   이 함수는 반지름 값을 입력받아 원의 면적을 계산하여 반환합니다. 이 함수는 단순히 값을 반환하는 역할만 하며, 상태를 변경하지 않기 때문에 순수 함수입니다.

## 언제 사용하나요?

- **순수한 계산 함수**나 **상태 조회 함수**에 주로 사용됩니다. 예를 들어, 특정 값의 제곱을 구하거나 벡터 연산을 수행하는 함수, 또는 객체의 상태를 읽고 반환하는 함수에서 사용됩니다.
- 함수의 결과가 **호출할 때마다 동일**하며, **다른 시스템의 상태에 영향을 미치지 않는** 경우 사용합니다.

## 예시: `BlueprintCallable` vs `BlueprintPure`

다음 예시는 두 키워드의 차이를 설명합니다:

- **`BlueprintCallable`**:

  ```cpp
  UFUNCTION(BlueprintCallable, Category="Game")
  void IncreaseScore(int Amount);
  ```

  이 함수는 **점수를 증가**시키며, 호출 시 게임 상태에 영향을 미칩니다. 따라서 실행 흐름을 제어하는 **실행 핀**이 필요합니다.

- **`BlueprintPure`**:

  ```cpp
  UFUNCTION(BlueprintPure, Category="Game")
  int GetScore() const;
  ```

  이 함수는 **현재 점수를 단순히 반환**하는 함수로, 상태를 변경하지 않습니다. 실행 핀이 없으며, 순수 함수로 동작합니다.

## 요약
- **`BlueprintPure`**: 블루프린트에서 **상태를 변경하지 않고 값을 반환하는 함수**를 정의하는 데 사용됩니다.
- **실행 핀 없이** 속성 노드처럼 동작하며, 항상 반환값이 있어야 합니다.
- 주로 **읽기 전용 함수**나 **계산 함수**에 사용됩니다.


# 언리얼 엔진 리플렉션 프로그래밍

언리얼 엔진에서 **리플렉션(Reflection)**은 **코드 메타데이터**를 기반으로 객체와 속성, 함수 등을 런타임에 **동적으로 접근**하고 **조작**할 수 있는 기능을 의미합니다. 이 개념은 언리얼의 **UCLASS**, **USTRUCT**, **UENUM**, **UFUNCTION**, **UPROPERTY** 같은 매크로들을 통해 제공되며, 주로 **언리얼 오브젝트 시스템**과 **블루프린트 통합**에 활용됩니다.

언리얼에서의 리플렉션은 개발자가 게임 객체의 클래스와 속성을 런타임에 쉽게 접근하고, 이를 활용해 블루프린트와의 상호작용, 직렬화, 편집기에서의 노출, 네트워크 복제 등을 가능하게 합니다.

### 리플렉션의 주요 기능

1. **런타임 객체 정보 접근**:
   - 리플렉션 시스템을 통해 객체의 클래스 정보, 속성 및 메서드에 런타임에서 동적으로 접근할 수 있습니다. 이를 통해 **클래스 이름**, **함수 이름**, **속성 타입** 등을 확인하고, 해당 객체의 데이터를 조작할 수 있습니다.
   
2. **블루프린트 통합**:
   - 언리얼의 리플렉션 시스템은 **블루프린트**와 **C++ 코드**를 연결해 줍니다. C++로 작성된 클래스와 함수를 블루프린트에서 사용할 수 있게 하기 위해 `UFUNCTION`과 `UPROPERTY` 같은 매크로를 사용하여 리플렉션을 적용합니다.
   - 이를 통해 C++ 코드에서 정의한 함수나 속성을 블루프린트에서 쉽게 호출하고 조작할 수 있게 됩니다.

3. **에디터 노출**:
   - 리플렉션을 통해 언리얼 엔진 에디터에서 클래스 속성을 노출할 수 있습니다. `UPROPERTY` 매크로를 사용하면, 에디터에서 해당 속성을 직관적으로 수정하거나 접근할 수 있게 만들 수 있습니다.
   - 예시:
     ```cpp
     UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Settings")
     float Health;
     ```
     이 코드는 `Health` 변수를 에디터에서 수정할 수 있게 하며, 블루프린트에서도 읽기/쓰기 가능하게 설정합니다.

4. **직렬화(Serialization)**:
   - 리플렉션 시스템을 통해 객체 데이터를 저장하거나 불러오는 과정인 **직렬화**를 자동으로 처리할 수 있습니다. 이를 통해 언리얼 엔진의 저장/불러오기 시스템을 간편하게 구축할 수 있습니다.

5. **네트워크 복제**:
   - 멀티플레이어 게임에서 객체의 속성을 네트워크를 통해 자동으로 복제하는 기능을 지원합니다. 리플렉션 시스템을 사용하여 `UPROPERTY` 매크로에 `Replicated` 옵션을 지정하면, 해당 속성이 서버와 클라이언트 간에 자동으로 동기화됩니다.
   - 예시:
     ```cpp
     UPROPERTY(Replicated)
     int32 AmmoCount;
     ```

6. **가비지 컬렉션**:
   - 리플렉션 시스템은 언리얼 엔진의 **가비지 컬렉션 시스템**과 밀접하게 연동됩니다. `UCLASS`로 선언된 객체들은 엔진의 가비지 컬렉션 시스템이 관리하며, 불필요한 메모리 사용을 방지할 수 있습니다.

### 리플렉션을 사용하는 매크로들

1. **UCLASS**:
   - 클래스에 리플렉션을 적용하여 언리얼 엔진의 객체로 인식되게 만드는 매크로입니다. 이를 통해 에디터나 블루프린트에서 해당 클래스를 사용할 수 있습니다.
     ```cpp
     UCLASS()
     class AMyCharacter : public ACharacter
     {
         GENERATED_BODY()
     };
     ```

2. **UFUNCTION**:
   - 클래스 내 함수를 블루프린트나 엔진 시스템에서 사용할 수 있도록 지정하는 매크로입니다. 함수가 블루프린트에서 호출되거나, 리플렉션 시스템을 통해 런타임에 동적으로 호출되도록 할 수 있습니다.
     ```cpp
     UFUNCTION(BlueprintCallable, Category="Game")
     void Jump();
     ```

3. **UPROPERTY**:
   - 클래스 속성을 리플렉션 시스템에서 관리하고, 블루프린트 또는 에디터에서 해당 속성을 사용할 수 있도록 만드는 매크로입니다.
     ```cpp
     UPROPERTY(EditAnywhere, BlueprintReadWrite, Category="Stats")
     float Health;
     ```

4. **USTRUCT**:
   - 리플렉션이 적용된 사용자 정의 구조체를 선언할 때 사용됩니다. 이를 통해 구조체도 블루프린트와 연동할 수 있으며, 객체 직렬화 및 네트워크 복제에도 사용할 수 있습니다.
     ```cpp
     USTRUCT(BlueprintType)
     struct FPlayerStats
     {
         GENERATED_BODY()

         UPROPERTY(EditAnywhere, BlueprintReadWrite)
         int32 Score;
     };
     ```

5. **UENUM**:
   - 열거형(enum)에 리플렉션을 적용하여 블루프린트에서 해당 열거형을 사용할 수 있게 해주는 매크로입니다.
     ```cpp
     UENUM(BlueprintType)
     enum class EWeaponType : uint8
     {
         Pistol UMETA(DisplayName="Pistol"),
         Rifle UMETA(DisplayName="Rifle")
     };
     ```

### 리플렉션의 주요 활용 예시

1. **블루프린트에서 C++ 함수 호출**:
   C++로 작성한 함수를 블루프린트에서 호출하여 게임플레이를 제어하거나 게임 로직을 확장할 수 있습니다. 예를 들어, 점프 기능을 C++로 작성하고 블루프린트에서 호출하는 방식입니다.

2. **런타임 동적 객체 생성**:
   리플렉션 시스템을 통해 **런타임에 특정 클래스의 객체를 생성**할 수 있습니다. 예를 들어, 문자열로 클래스 이름을 받아서 런타임에 해당 클래스를 생성하는 기능을 구현할 수 있습니다.

3. **에디터에서 변수 조정**:
   리플렉션을 사용하면 에디터에서 변수들을 쉽게 노출하고, 에디터 사용자들이 직접 값을 조정하여 게임플레이에 영향을 줄 수 있도록 할 수 있습니다.

### 요약
언리얼 엔진에서 **리플렉션**은 객체와 그 속성, 메서드 등을 런타임에 동적으로 접근하고, 블루프린트와의 상호작용을 쉽게 하도록 해주는 시스템입니다. 이를 통해 **블루프린트 통합**, **에디터 노출**, **직렬화**, **네트워크 복제**와 같은 다양한 기능을 구현할 수 있습니다.
